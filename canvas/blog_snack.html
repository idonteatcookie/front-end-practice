<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>blog_snack</title>
    <style>
        #canvas {
             background-color: #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <p>
        <button onclick="start()">å¼€å§‹</button>
        <button onclick="switch_ai()">è‡ªåŠ¨</button>
    </p>
    <p>
        <label for="range">é€Ÿåº¦</label>
        <input type="range" id="range" min="50" max="1000" onchange="changeSpeed(this.value)">

    </p>
    <script>
        const GRID_WIDTH = 10;  // æ ¼å­çš„è¾¹é•¿
        const GAP_WIDTH = 2;    // ç©ºéš™çš„è¾¹é•¿
        const ROW = 8;         // ä¸€å…±æœ‰å¤šå°‘è¡Œæ ¼å­&æ¯è¡Œæœ‰å¤šå°‘ä¸ªæ ¼å­
        const COLOR = '#fff';   // è›‡çš„é¢œè‰²
        const BG_COLOR = '#000';// èƒŒæ™¯é¢œè‰²
        const FOOD_COLOR = 'red'; // é£Ÿç‰©é¢œè‰²
        const INTERVAL = 300;

        const UP = 0, LEFT = 1, RIGHT = 2, DOWN = 3;    // å®šä¹‰è›‡å‰è¿›çš„æ–¹å‘
        const CHANGE = [ [0, -1], [-1, 0], [1, 0], [0, 1] ]; // æ¯ä¸ªæ–¹å‘å‰è¿›æ—¶æ ¼å­åæ ‡çš„å˜åŒ–

        let isAI = false;
        let inteval = 300;
        let newInterval = 300;

        let canvas = document.getElementById('canvas');
        canvas.height = GRID_WIDTH * ROW + GAP_WIDTH * (ROW + 1);
        canvas.width = GRID_WIDTH * ROW + GAP_WIDTH * (ROW + 1);
        let ctx = canvas.getContext('2d');

        let snack, dir, map, nextDir, food;
        let timer;

        function changeSpeed(v) {
            newInterval = 1000 - v + 50;
        }

        function switch_ai() { isAI = !isAI; }

        function initialize() {
            snack = [ [2, 2], [3, 2], [4, 2]]; // åˆå§‹åŒ–ä¸€æ¡ğŸ
            nextDir = dir = RIGHT; // åˆå§‹åŒ–ä¸€ä¸ªæ–¹å‘
            map = [];
            for (let i = 0; i < ROW * ROW; i++) map[i] = 0;
            for (let i = 0; i < snack.length; i++) map[ getGridNumber(snack[i]) ] = 1;
            window.onkeydown = function(e) {
                // e.preventDefault();
                if (e.key === 'ArrowUp') nextDir = UP;
                if (e.key === 'ArrowDown') nextDir = DOWN;
                if (e.key === 'ArrowRight') nextDir = RIGHT;
                if (e.key === 'ArrowLeft') nextDir = LEFT;
            }
            drawSnack(ctx, snack, COLOR);
            drawFood();
        }

        function start() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            initialize();
            move();
        }

        function move() {
            timer = setInterval(() => {
                if (newInterval !== inteval) {
                    inteval = newInterval;
                    if (timer) {
                        clearInterval(timer);
                        timer = null;
                    }
                    move();
                }
                // æ¯éš”ä¸€æ®µæ—¶é—´å°±åˆ·æ–°ä¸€æ¬¡
                // åªæœ‰è½¬å¤´æ–¹å‘ä¸å½“å‰æ–¹å‘å‚ç›´çš„æ—¶å€™ æ‰æ”¹å˜æ–¹å‘
                if (isAI) nextDir = getNextDirection();
                if (nextDir !== dir && nextDir + dir !== 3) dir = nextDir;
                let head = snack[snack.length - 1]; // è›‡å¤´
                let change = CHANGE[dir];           // ä¸‹ä¸€ä¸ªæ ¼å­å‰è¿›ä½ç½®
                let newGrid = [head[0] + change[0], head[1] + change[1]]; // æ–°æ ¼å­çš„ä½ç½®
                if (!isValidPosition(newGrid, map)) { // æ–°ä½ç½®ä¸åˆæ³• æ¸¸æˆç»“æŸ
                    clearInterval(timer);
                    return;
                }
                snack.push(newGrid);    // æ–°æ ¼å­åŠ å…¥è›‡èº«çš„æ•°ç»„ä¸­
                map[getGridNumber(newGrid)] = 1;
                gradientRect(ctx, ...getUniteRect(newGrid, getBetweenTwoGridGap(head, newGrid)), dir, COLOR, inteval);
                if (newGrid[0] === food[0] && newGrid[1] === food[1]) {
                    drawFood();
                    return;
                }
                let delGrid = snack.shift();    // åˆ é™¤è›‡å°¾-æœ€åä¸€ä¸ªå…ƒç´ 
                map[getGridNumber(delGrid)] = 0;
                gradientRect(ctx, ...getUniteRect(delGrid, getBetweenTwoGridGap(delGrid, snack[0])), 
                    getDirection(delGrid, snack[0]), BG_COLOR, inteval);
            }, inteval);
        }

        // è·å– g1 åˆ° g2 çš„æœ€çŸ­è·¯å¾„
        function bfs(g1, g2, visited) {
            let x = 0;
            let queue = [g1];
            let lastEle = {}; // è®°å½•æ¯ä¸€ä¸ªç‚¹çš„å‰ä¸€ä¸ªç‚¹æ˜¯ä»€ä¹ˆ
            let path = [];
            visited[getGridNumber(g1)] = 1;
            while (queue.length) {
                let now = queue.shift();
                if (now[0] === g2[0] && now[1] === g2[1]) {
                    // å¦‚æœè¿™ä¸ªç‚¹å°±æ˜¯g2 è¯æ˜æ‰¾åˆ°äº†æœ€çŸ­è·¯å¾„
                    path.push(now);
                    while (now = lastEle[now]) {
                        path.push(now);
                    }
                    return path;
                }
                // ä¸ºäº†è¾¾åˆ°éšæœºçš„æ•ˆæœ...é˜²æ­¢æ­»å¾ªç¯
                let permutation = getRandomPermutation(4);
                for (let i = 0; i < 4; i++) {
                    let change = CHANGE[ permutation[i] ];
                    let next = [now[0] + change[0], now[1] + change[1]];
                    // å¦‚æœä¸‹ä¸€ä¸ªä½ç½®åˆæ³•çš„è¯
                    if (next[0] >= 0 && next[0] < ROW && next[1] >= 0 && next[1] < ROW && 
                            (!visited[ getGridNumber(next) ] || next[0] === g2[0] && next[1] === g2[1])) {
                        visited[ getGridNumber(next) ] = 1;
                        lastEle[next] = now;
                        queue.push(next);
                    }
                }
            }
            return path;
        }
        // è·å–ä¸¤ç‚¹ä¹‹é—´çš„æœ€é•¿è·¯å¾„ 
        // å‚è€ƒ: https://github.com/chuyangliu/Snake/blob/master/docs/algorithms.md#longest-path
        function longestPath(g1, g2, visited) {
            let sp = bfs(g1, g2, [...visited]);
            if (!sp.length) return sp;
            for (let g of sp) {
                visited[getGridNumber(g)] = 1;
            }
            let hasChange;
            do {
                hasChange = false;
                for (let i = 0; i < sp.length - 1; i++) {
                    let now = sp[i], next = sp[i+1];
                    let g1, g2; // æ‰©å±•å‡ºä¸¤ä¸ªæ ¼å­
                    if (sp[i][1] === sp[i+1][1]) {
                        // ç›¸é‚»ä¸¤ä¸ªæ ¼å­æ˜¯æ°´å¹³æ’åˆ—çš„ å°è¯•å‘ä¸Šä¸‹æ‰©å±•
                        let g1 = [ now[0] + CHANGE[UP][0], now[1] + CHANGE[UP][1] ];
                        let g2 = [ next[0] + CHANGE[UP][0], next[1] + CHANGE[UP][1] ];
                        if (isValidPosition(g1, visited) && isValidPosition(g2, visited)) {
                            sp.splice(i + 1, 0, g1, g2);
                            visited[getGridNumber(g1)] = visited[getGridNumber(g2)] = 1;
                            hasChange = true;
                            break;
                        }
                        // ä¸‹
                        g1 = [ now[0] + CHANGE[DOWN][0], now[1] + CHANGE[DOWN][1] ];
                        g2 = [ next[0] + CHANGE[DOWN][0], next[1] + CHANGE[DOWN][1] ];
                        if (isValidPosition(g1, visited) && isValidPosition(g2, visited)) {
                            sp.splice(i + 1, 0, g1, g2);
                            visited[getGridNumber(g1)] = visited[getGridNumber(g2)] = 1;
                            hasChange = true;
                            break;
                        }
                    } else {
                        // å·¦
                        let g1 = [ now[0] + CHANGE[LEFT][0], now[1] + CHANGE[LEFT][1] ];
                        let g2 = [ next[0] + CHANGE[LEFT][0], next[1] + CHANGE[LEFT][1] ];
                        if (isValidPosition(g1, visited) && isValidPosition(g2, visited)) {
                            sp.splice(i + 1, 0, g1, g2);
                            visited[getGridNumber(g1)] = visited[getGridNumber(g2)] = 1;
                            hasChange = true;
                            break;
                        }
                        // å³
                        g1 = [ now[0] + CHANGE[RIGHT][0], now[1] + CHANGE[RIGHT][1] ];
                        g2 = [ next[0] + CHANGE[RIGHT][0], next[1] + CHANGE[RIGHT][1] ];
                        if (isValidPosition(g1, visited) && isValidPosition(g2, visited)) {
                            sp.splice(i + 1, 0, g1, g2);
                            visited[getGridNumber(g1)] = visited[getGridNumber(g2)] = 1;
                            hasChange = true;
                            break;
                        }
                    }
                }
            } while(hasChange);
            return sp;
        }

        /**
        if å­˜åœ¨è›‡å¤´åˆ°è‹¹æœçš„è·¯å¾„
            è™šæ‹Ÿè›‡å»å°è¯•åƒè‹¹æœ
            if åƒå®Œè‹¹æœåèƒ½æ‰¾åˆ°è›‡å¤´åˆ°è›‡å°¾çš„è·¯å¾„
                BFSåˆ°è›‡å°¾
            else if å­˜åœ¨è›‡å¤´åˆ°è›‡å°¾çš„è·¯å¾„
                èµ°è›‡å¤´åˆ°è›‡å°¾çš„æœ€é•¿è·¯å¾„
            else
                éšæœºä¸€ä¸ªæ–¹å‘
        else if å­˜åœ¨è›‡å¤´åˆ°è›‡å°¾çš„è·¯å¾„
            èµ°è›‡å¤´åˆ°è›‡å°¾çš„æœ€é•¿è·¯å¾„
        else
            éšæœºä¸€ä¸ªæ–¹å‘
        **/

        function getRandomPermutation(n) {
            let ans = [];
            let vis = [];
            for (let i = 0; i < n; i++) {
                let t = Math.floor(Math.random() * (n - i));
                for (let j = 0; ; j++) {
                    if (!vis[j] && !t--) {
                        ans[i] = j;
                        vis[j] = 1;
                        break;
                    }
                }
            }
            return ans;
        }

        function getLastEle(arr) {
            return arr[arr.length - 1];
        }
        // è·å–ä¸¤ä¸ªæ ¼å­ä¹‹é—´çš„... æ›¼å“ˆé¡¿è·ç¦»ï¼Ÿ
        function getTwoGridDis(g1, g2) {
            return Math.abs(g1[0] - g2[0]) + Math.abs(g1[1] - g2[1]);
        }

        // è·å¾—ä¸‹ä¸€æ­¥ç§»åŠ¨çš„æ–¹å‘
        function getNextDirection() {
            // è·å–è›‡å¤´åˆ°é£Ÿç‰©çš„è·¯å¾„
            let path = bfs(getLastEle(snack), food, [...map]);
            // å¦‚æœè·¯å¾„å­˜åœ¨çš„è¯
            if (snack.length * 2 < ROW * ROW && path.length) {
                // å°è¯•å»æŒ‰ç…§è¿™ä¸ªè·¯å¾„åƒè‹¹æœ
                let virtualSnack = [...snack];
                let virtualMap = [...map];
                for (let i = path.length - 2; i >= 0; i--) {
                    virtualSnack.push(path[i]);
                    virtualMap[getGridNumber(path[i])] = 1;
                    i && (virtualMap[getGridNumber(virtualSnack.shift())] = 0);
                }
                // åƒå®Œä¹‹åçœ‹çœ‹èƒ½ä¸èƒ½æ‰¾åˆ°è›‡å°¾
                let toTailPath = bfs(getLastEle(virtualSnack), virtualSnack[0], [...virtualMap]);
                if (toTailPath.length) {
                    // å¦‚æœèƒ½æ‰¾åˆ°è›‡å°¾ è¯æ˜ä¸€å¼€å§‹åƒè‹¹æœçš„è·¯å¾„æ²¡é—®é¢˜ å¯ä»¥é‚£ä¹ˆèµ°
                    return getDirection(getLastEle(path), path[path.length-2]);
                }
                // åƒå®Œè‹¹æœæ‰¾ä¸åˆ°è›‡å°¾ åƒäº†è‹¹æœä¹Ÿæ²¡ç”¨ è¿˜æ˜¯ç›´æ¥æ‰¾è›‡å°¾å§
            }
            let lp = longestPath(getLastEle(snack), snack[0], [...map]);
            if (lp.length) return getDirection(getLastEle(lp), lp[lp.length-2]);
            // èµ°æŠ•æ— è·¯ éšä¾¿é€‰å§
            for (let i = 0; i < 4; i++) {
                let change = CHANGE[i];
                let next = [getLastEle(snack)[0] + change[0], getLastEle(snack)[1] + change[1]];
                if (isValidPosition(next, map)) return i;
            }
            return Math.floor(Math.random() * 4);
        }
        // ç”»é£Ÿç‰©
        function drawFood() {
            food = getFoodPosition();
            ctx.fillStyle = FOOD_COLOR;
            ctx.fillRect(...getGridULCoordinate(food), GRID_WIDTH, GRID_WIDTH);
        }
        // åˆ¤æ–­ä¸€ä¸ªæ–°ç”Ÿæˆçš„æ ¼å­ä½ç½®æ˜¯å¦åˆæ³•
        function isValidPosition(g, visited) {
            if (g[0] >= 0 && g[0] < ROW && g[1] >= 0 && g[1] < ROW && !visited[getGridNumber(g)]) return true;
            return false;
        }
        // è·å–ä¸€ä¸ªæ ¼å­çš„ç¼–å·
        function getGridNumber(g) {
            return g[0] * ROW + g[1];
        }
        function getFoodPosition() {
            let r = Math.floor(Math.random() * (ROW * ROW - snack.length)); // éšæœºè·å–ä¸€ä¸ªæ•°å­— æ•°å­—èŒƒå›´å’Œå‰©ä½™çš„æ ¼å­æ•°ç›¸åŒ
            for (let i = 0; ; i++) {    // åªæœ‰é‡åˆ°ç©ºä½çš„æ—¶å€™ è®¡æ•°å› r æ‰å‡ä¸€
                if (!map[i] && --r < 0) return [Math.floor(i / ROW), i % ROW];
            }
        }
        // ç»™å®šä¸€ä¸ªæ ¼å­çš„åæ ‡å’Œä¸€ä¸ªæ ¼å­é—´éš™çš„çŸ©å½¢ï¼ˆå·¦ä¸Šè§’ï¼Œå®½ï¼Œé«˜ï¼‰ è¿”å›ä¸¤ä¸ªåˆå¹¶çš„çŸ©å½¢ çš„å·¦ä¸Šè§’ã€å³ä¸‹è§’ åæ ‡
        function getUniteRect(g, rect) {
            let p = getGridULCoordinate(g);
            if (p[0] === rect[0] && p[1] < rect[1] ||   // çŸ©å½¢æ˜¯åœ¨æ ¼å­æ­£ä¸‹æ–¹
                p[1] === rect[1] && p[0] < rect[0]) {   // çŸ©å½¢åœ¨æ ¼å­çš„æ­£å³æ–¹
                return [p[0], p[1], rect[0] + rect[2], rect[1] + rect[3]];
            } else if (p[0] === rect[0] && p[1] > rect[1] || // çŸ©å½¢æ˜¯åœ¨æ ¼å­æ­£ä¸Šæ–¹
                p[1] === rect[1] && p[0] > rect[0]) { // çŸ©å½¢åœ¨æ ¼å­çš„æ­£å·¦æ–¹
                return [rect[0], rect[1], p[0] + GRID_WIDTH, p[1] + GRID_WIDTH];
            }
        }
        // ä»æ ¼å­1 ç§»åŠ¨åˆ°æ ¼å­2 çš„æ–¹å‘
        function getDirection(g1, g2) {
            if (g1[0] === g2[0] && g1[1] < g2[1]) return DOWN;
            if (g1[0] === g2[0] && g1[1] > g2[1]) return UP;
            if (g1[1] === g2[1] && g1[0] < g2[0]) return RIGHT;
            if (g1[1] === g2[1] && g1[0] > g2[0]) return LEFT;
        }

        // æ…¢æ…¢çš„å¡«å……ä¸€ä¸ªçŸ©å½¢ ï¼ˆçœŸçš„ä¸çŸ¥é“åˆ™æ€ä¹ˆå†™ çå†™...åŠ¨ç”»çš„æ‰§è¡Œæ—¶é—´å¯èƒ½ä¸ç­‰äºduration ä½†ä¸€å®šè¦ä¿è¯<=duration
        // ä¼ å…¥çš„æ˜¯çŸ©å½¢å·¦ä¸Šè§’å’Œå³ä¸‹è§’çš„åæ ‡ ä»¥åŠæ¸å˜çš„æ–¹å‘
        function gradientRect(ctx, x1, y1, x2, y2, dir, color, duration) {
            let dur = 20;
            let times = Math.floor(duration / dur); // æ›´æ–°æ¬¡æ•°
            let nowX1 = x1, nowY1 = y1, nowX2 = x2, nowY2 = y2;
            let dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0;
            if (dir === UP) { dy1 = (y1 - y2) / times; nowY1 = y2; }
            if (dir === DOWN) { dy2 = (y2 - y1) / times; nowY2 = y1; }
            if (dir === LEFT) { dx1 = (x1 - x2) / times; nowX1 = x2; }
            if (dir === RIGHT) { dx2 = (x2 - x1) / times; nowX2 = x1; }
            let startTime = Date.now();
            let timer = setInterval(() => {
                nowX1 += dx1, nowX2 += dx2, nowY1 += dy1, nowY2 += dy2; // æ›´æ–°
                let runTime = Date.now() - startTime;
                if (nowX1 < x1 || nowX2 > x2 || nowY1 < y1 || nowY2 > y2 || runTime >= duration - dur) {
                    nowX1 = x1, nowX2 = x2, nowY1 = y1, nowY2 = y2;
                    clearInterval(timer);
                }
                ctx.fillStyle = color;
                ctx.fillRect(nowX1, nowY1, nowX2 - nowX1, nowY2 - nowY1);
            }, dur);
        }
        // æ ¹æ®snackäºŒç»´æ•°ç»„ç”»ä¸€æ¡è›‡
        function drawSnack(ctx, snack, color) {
            ctx.fillStyle = color;
            for (let i = 0; i < snack.length; i++) {
                ctx.fillRect(...getGridULCoordinate(snack[i]), GRID_WIDTH, GRID_WIDTH);
                if (i) {
                    ctx.fillRect(...getBetweenTwoGridGap(snack[i], snack[i - 1]));
                }
            }
        }
        // ä¼ å…¥ä¸€ä¸ªæ ¼å­ è¿”å›å·¦ä¸Šè§’åæ ‡
        function getGridULCoordinate(g) {
            return [g[0] * (GRID_WIDTH + GAP_WIDTH) + GAP_WIDTH, g[1] * (GRID_WIDTH + GAP_WIDTH) + GAP_WIDTH];
        }
        // ä¼ å…¥ä¸¤ä¸ªæ ¼å­ è¿”å›ä¸¤ä¸ªæ ¼å­ä¹‹é—´çš„çŸ©å½¢ç¼éš™
        // è¿™é‡Œä¼ å…¥çš„ä¸¤ä¸ªæ ¼å­å¿…é¡»æ˜¯ç›¸é‚»çš„
        // è¿”å›ä¸€ä¸ªæ•°ç»„ åˆ†åˆ«æ˜¯è¿™ä¸ªçŸ©å½¢ç¼éš™çš„ å·¦ä¸Šè§’æ¨ªåæ ‡ å·¦ä¸Šè§’çºµåæ ‡ å®½ é«˜
        function getBetweenTwoGridGap(g1, g2) {
            let width = GRID_WIDTH + GAP_WIDTH;
            if (g1[0] === g2[0]) { // æ¨ªåæ ‡ç›¸åŒ æ˜¯çºµå‘ç›¸é‚»çš„ä¸¤ä¸ªæ ¼å­
                let x = g1[0] * width + GAP_WIDTH;
                let y = Math.min(g1[1], g2[1]) * width + width;
                return [x, y, GRID_WIDTH, GAP_WIDTH];
            } else { // çºµåæ ‡ç›¸åŒ æ˜¯æ¨ªå‘ç›¸é‚»çš„ä¸¤ä¸ªæ ¼å­
                let x = Math.min(g1[0], g2[0]) * width + width;
                let y = g1[1] * width + GAP_WIDTH;
                return [x, y, GAP_WIDTH, GRID_WIDTH];
            }
        }
    </script>
</body>
</html>